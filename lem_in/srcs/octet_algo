/* ************************************************************************** */
/*                                                          LE - /            */
/*                                                              /             */
/*   algo_lemin.c                                     .::    .:/ .      .::   */
/*                                                 +:+:+   +:    +:  +:+:+    */
/*   By: rgermain <marvin@le-101.fr>                +:+   +:    +:    +:+     */
/*                                                 #+#   #+    #+    #+#      */
/*   Created: 2019/03/18 19:46:37 by rgermain     #+#   ##    ##    #+#       */
/*   Updated: 2019/03/20 11:53:57 by loiberti    ###    #+. /#+    ###.fr     */
/*                                                         /                  */
/*                                                        /                   */
/* ************************************************************************** */

#include "lem_in.h"
#include <stdio.h>

char	*name(t_data *data, int nb)
{
	t_room **room;
	int i;

	room = &(data->room);
	i = 0;
	if (nb == 0 || nb == 1)
	{
		if (nb == 0)
			return (data->start->name);
		else
			return (data->end->name);
	}
	nb -= 2;
	while ((*room) && i < nb)
	{
		room = &((*room)->next);
		i++;
	}
	if ((*room))
		return ((*room)->name);
	return ("null");
}

void	put_resolve(t_data *data, char index)
{
	static	unsigned long long nb = 0;

	if (index == 1)
		nb++;
	else
		ft_printf("total = %d\n", nb);
}


void	remove_node(t_data *data, int i)
{
	size_t	k;
	size_t	l;

	k = 0;
	l = 0;
	while (((l * 8) + k) < (data->room_nb + 2))
	{
		if (!!(data->matrix.tab[i][l] & (1 << (k))))
			data->matrix.tab[i][l] ^= (1 << (k));
		k++;
		if (k == 8)
		{
			k = 0;
			l++;
		}
	}
	k = 0;
	l = 0;
	while (l < (data->room_nb + 2))
	{
		if (!!(data->matrix.tab[l][i / 8] & (1 << ((i % 8)))))
			data->matrix.tab[l][(i / 8)] ^= (1 << (((i % 8))));
		l++;
	}

}

bool	recursive_algo(t_data *data, int  i, int  j, unsigned long long nb)
{
	if (i == 1 || j == 1)
	{
		ft_printf("%*c%s[OK]%s\n", nb, '|', T_GREEN, T_WHITE);
		ft_printf("%*c[%s,%s]\n", nb, ' ', name(data, i), name(data, j));
		put_resolve(data, 1);
		return (TRUE);
	}
	size_t l;
	size_t k;
	char ret = 0;
	
	l = 0;
	k = 0;
	remove_node(data, i);
	while (k + (l * 8) < (data->room_nb + 2))
	{
		if (!!(data->matrix.tab[j][l] & (1 << (k))))
		{
			if (recursive_algo(data, j, ((l * 8) + k), nb + 4))
			{
				ft_printf("%*c[%s,%s]\n", nb, ' ', name(data, i), name(data, j));
				ret = 1;
			}
		}
		k++;
		if (k == 8)
		{
			k = 0;
			l++;
		}
	}
	add_node(data, i);
	if (ret  == 1)
		return (TRUE);
	return (FALSE);
}

void	algo_lemin(t_data *data)
{
	size_t j;
	size_t k;
	size_t nb;
	int	i;

	nb = 0;
	j = 0;
	k = 0;
	i = 0;
	while (k + (j * 8) < (data->room_nb + 2))
	{
		if (!!(data->matrix.tab[i][j] & (1 << (k))))
			recursive_algo(data, i, ((j * 8) + k), nb + 4);
		k++;
		if (k == 8)
		{
			k = 0;
			j++;
		}
	}
	put_resolve(data, 0);
}
