TODO

- pass + !d -> add Salted__X OK
- pass + d
    (a  -> decode
    !a -> check Salted__ -> get salt -> remove 16 first bits

ERROR -> Moins de 17 -> error reading input file
ERROR ->  false Salted__  -> bad magic number
Else -> bad decrypt

Check alloc
Check flag when decrypt ('cause we modify flag for b64)
Check EVP_BYTES_TO_KEY
Secure ft_random
What is happening when pass + key
Pas d'IV when CBC -> ERROR


-a b64 decode/encode according to encrypt/decrypt mode S OK
-e encrypt (default) S OK
-d decrypt S OK
-P print S OK


-o output A OK
-i input A OK


-k Key Hex A OK
-v IV hex A OK
-s Salt hex A OK
-p password A


Hex 1: U2FsdGVkX1/QP8Ho2X8AAKoLZAhmskXc
Hex 2: qgtkCGayRdw=

U2FsdGVkX1/QP8Ho2X8AAKoLZAhmskXc

U2FsdGVkX1/QP8Ho2X8AAK

S  a  l  t  e  d  _  _
U2Fs dGVk X1/
53 61 6c 74 65 64 5f 5f 

D0 3F 41 AE F0 7F 00 00
QP8H o2X8 AAK
d0 3f c1 e8 d9 7f 00 00

-K -> decrypt -> pas de condition

-pass -> input contient Salted__X -> on récupère le Salt à partir de l'input et on déduit le clef par ce biais
0. (-a: decode)
1. calcul key with 8->16 bytes of input 
2. remove 16 first bytes
3. process



void	EVP_bytes_to_Key(t_hash *h)
{
	unsigned char salt[8];
	unsigned char *buf;
	int			  buf_size;

	//if (test_bit(&h->flag, FLAG_P) && test_bit(&h->flag, FLAG_D))
	//{
	//	ft_printf("bonjour");
	//	// check if SALTED__
	//	buf_size = test_bit(&h->flag, FLAG_AA) ? 22 : 16;
	//	if (!(buf = ft_memalloc(buf_size + 1)))
	//		print_and_quit("Congrats, you broke malloc.\n", 2);
	//	int rt = read(h->fd, h->line, buf_size); // secure here
	//	ft_printf("%d %d %s\n", rt, buf_size, buf);
	//	exit(0);
	//}	
	//else
	//{
		if (test_bit(&h->flag, FLAG_S))
			ft_uint64_to_str(&h->des.salt, salt);
		else
		{
			ft_random(8, salt); // secure here
			ft_str_to_uint64(&h->des.salt, salt, 0);
		}
	//}
	h->arg = ustrjoin(h->des.password, salt); // secure here
	md5_custom(h);
	ft_str_to_uint64(&h->des.key, h->md5.digest, 0);
	ft_str_to_uint64(&h->des.iv, h->md5.digest, 8);
}