TODO

- pass + !d -> add Salted__X OK
- pass + d
    (a  -> decode
    !a -> check Salted__ -> get salt -> remove 16 first bits

ERROR -> Moins de 17 -> error reading input file
ERROR ->  false Salted__  -> bad magic number
Else -> bad decrypt

-> Si Key pas de pass possible.
Check alloc
Check flag when decrypt ('cause we modify flag for b64)
Check EVP_BYTES_TO_KEY
Secure ft_random
What is happening when pass + key
Pas d'IV when CBC -> ERROR


-a b64 decode/encode according to encrypt/decrypt mode S OK
-e encrypt (default) S OK
-d decrypt S OK
-P print S OK


-o output A OK
-i input A OK


-k Key Hex A OK
-v IV hex A OK
-s Salt hex A OK
-p password A


Hex 1: U2FsdGVkX1/QP8Ho2X8AAKoLZAhmskXc
Hex 2: qgtkCGayRdw=

U2FsdGVkX1/QP8Ho2X8AAKoLZAhmskXc

U2FsdGVkX1/QP8Ho2X8AAK

S  a  l  t  e  d  _  _
U2Fs dGVk X1/
53 61 6c 74 65 64 5f 5f 

D0 3F 41 AE F0 7F 00 00
QP8H o2X8 AAK
d0 3f c1 e8 d9 7f 00 00

-K -> decrypt -> pas de condition

-pass -> input contient Salted__X -> on récupère le Salt à partir de l'input et on déduit le clef par ce biais
0. (-a: decode)
1. calcul key with 8->16 bytes of input 
2. remove 16 first bytes
3. process
